"""
@date: 28rd May 2022
@author: Anna Ketteler
"""

import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), 'GENIE3'))
sys.path.append(os.path.join(os.path.dirname(__file__)))
from GENIE3_python import GENIE3 as gn
import preprocessing as prp
import argparse
import numpy as np
import pandas as pd
import csv
import datetime
from sklearn.preprocessing import Normalizer

# partitioning of data set based on confounder
# required: preprocessed data; one col per gene, one row per sample; sample array in same order; gene array in same order
# specify data set path, genes you want to take into account and confounder for partitioning

parser = argparse.ArgumentParser(prog='data_partitioning.py',
                                description='CLI for running GENIE3 on confounder-based vs random partitions.',
                                usage='%(prog)s [options] path',)

parser.add_argument('cancer_type',
                       metavar='cancer_type',
                       type=str,
                       help='TCGA cancer type abbreviation (e.g. ´TCGA-BLCA´)')
parser.add_argument('confounder',
                       metavar='confounder',
                       type=str,
                       help='Confounder: ´sex´, ´race´, ´ethnicity´')
parser.add_argument('n',
                       metavar='n',
                       type=int,
                       help='Number of random partitions to generate')
parser.add_argument('m',
                       metavar='m',
                       type=int,
                       help='Number of confounder based partitions to generate')
parser.add_argument('nthreads',
                       metavar='nthreads',
                       type=int,
                       help='Number of threads used by GENIE3')
parser.add_argument('ntrees',
                       metavar='ntrees',
                       type=int,
                       help='Number of trees in ensemble trees generated by GENIE3')
parser.add_argument('-prp',
                        dest='do_preprocessing',
                        action='store_true', # stores the Boolean value True when the corresponding optional argument is specified
                        help='Preprocess the raw data. This option is required at the very first start of the script.')


####################################################################
# parameters
####################################################################
args = parser.parse_args()

cancer_type = args.cancer_type
confounder = args.confounder
do_preprocessing = args.do_preprocessing
n = args.n
m = args.m
nthreads=args.nthreads
ntrees=args.ntrees

####################################################################
# path handling
####################################################################
dateStart = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
print('Result folder time stamp: ' + str(dateStart))
cwd = os.getcwd()
raw_data_dir = os.path.join(cwd, 'input', str(cancer_type)+'_raw_data')
data_dir = os.path.join(cwd, 'input', str(cancer_type)+'_data')
results_dir = os.path.join(cwd, 'results')
timestamp_dir = os.path.join(results_dir, str(dateStart))
conf_results_dir = os.path.join(timestamp_dir, str(cancer_type)+'_conf_results')
rnd_results_dir = os.path.join(timestamp_dir, str(cancer_type)+'_rnd_results')

if not os.path.exists(results_dir):
    os.mkdir(results_dir)
if not os.path.exists(timestamp_dir):
    os.mkdir(timestamp_dir)
if not os.path.exists(conf_results_dir):
    os.mkdir(conf_results_dir)
if not os.path.exists(rnd_results_dir):
    os.mkdir(rnd_results_dir)

####################################################################
# start of script
####################################################################

if do_preprocessing:
    prp.preprocessToCsv(raw_data_dir, data_dir, cancer_type) # cancer_type only needed for file naming; TODO: later also for data download

####################################################################
# prepare final data set
####################################################################

######################
# get data: one col per gene, one row per sample and remove columns col where col.std() is 0
######################
df = pd.read_csv(os.path.join(data_dir, str(cancer_type)+'_data_set.csv'), sep='\t', index_col=0, header=0)
df = df.iloc[:, :100]
df = df.loc[:, (df.std() != 0)]
for col in df:
    df.rename({col: col.split('.')[0]}, axis=1, inplace=True)

prp.testDuplicateGenes(df.columns.copy())

######################
# filter samples (rows): only keep 'Primary Tumor' samples
######################
tum_samples = prp.getPrimaryTumorIndices(os.path.join(raw_data_dir, str(cancer_type)+'.GDC_phenotype.tsv'))[1]
df = df.filter(items = tum_samples, axis=0)

######################
# get list of regulators
######################
regulators = np.genfromtxt(fname=os.path.join(raw_data_dir, 'TFs_Ensembl_v_1.01.txt'), delimiter="\t", dtype=str)

######################
# group sample ids based on confounder-induced partitions
######################
(blocknames, conf_partition) = prp.getSampleIDsByConfounder(os.path.join(raw_data_dir, str(cancer_type)+'.GDC_phenotype.tsv'), confounder)

####################################################################
# start GENIE3 on confounder based partitions
####################################################################

for k in range(m):
    i = 0
    for block in conf_partition:

        if len(block) <=1:
            print('Block must contain at least two elements, otherwise, normalization to unit variance will cause NaN values.')
            break

        # generate partition: select samples from data set based on the index set that was prepared before
        final_df = df.filter(items = block, axis='index')
        final_df = final_df.loc[:, (final_df.std() != 0)]
        final_df = prp.normalizeToUnitVariance(final_df)
        gene_names = np.array(final_df.columns.copy())

        # filter from the set of regulators such genes that are not present in the filtered data set 
        mask = np.isin(regulators, gene_names)
        regulators = np.array(regulators)[mask]

        gene_names = gene_names.tolist()
        regulators = regulators.tolist()
        if len(regulators) < 1 or len(gene_names) < 1:
            print('no overlap of regulators and genes in data set. Skipping iteration.')
            break
        data = final_df.to_numpy()
        
        # Use Random Forest method
        tree_method='RF'
        # Number of randomly chosen candidate regulators at each node of a tree
        p = len(gene_names)
        K = p-1

        VIM3 = gn.GENIE3(data,tree_method=tree_method,K=K,nthreads=nthreads,ntrees=ntrees)
        gn.get_link_list(VIM3,gene_names=gene_names, regulators=regulators,file_name=os.path.join(conf_results_dir, 'ranking_iter_'+str(k)+'_confBlock_'+str(blocknames[i])+'.txt'))

        i = i+1

####################################################################
# start GENIE3 on n random partitions with corresponding fractions
####################################################################

# compute fractions for blocks in random partitions
pos = 0
cuts = []
for block in conf_partition:
    cuts.append(pos+len(block))
    pos = pos + len(block)

print(cuts)

# generate partitions according to the fractions computed above
for k in range(n): # n random partitions
    partition = []
    final_df = df.copy()
    samples_cpy = (final_df.index.values).copy()
    np.random.shuffle(samples_cpy)
    partition = np.split(samples_cpy, cuts[:-1])
    i = 0
    # iterate through partition
    for block in partition:
        if len(block) <=1:
            print('Block must contain at least two elements, otherwise, normalization to unit variance will cause NaN values.')
            break

        # generate partition: select samples from data set based on the index set that was prepared before
        final_df = df.filter(items = block, axis='index')
        final_df = final_df.loc[:, (final_df.std() != 0)]
        final_df = prp.normalizeToUnitVariance(final_df)
        gene_names = np.array(final_df.columns.copy())

        # filter from the set of regulators such genes that are not present in the filtered data set 
        mask = np.isin(regulators, gene_names)
        regulators = np.array(regulators)[mask]

        gene_names = gene_names.tolist()
        regulators = regulators.tolist()
        if len(regulators) < 1 or len(gene_names) < 1:
            print('no overlap of regulators and genes in data set. Skipping iteration.')
            break
        data = final_df.to_numpy()
        
        # Use Random Forest method
        tree_method='RF'
        # Number of randomly chosen candidate regulators at each node of a tree
        p = len(gene_names)
        K = p-1

        VIM3 = gn.GENIE3(data,tree_method=tree_method,K=K,nthreads=nthreads,ntrees=ntrees)

        gn.get_link_list(VIM3,gene_names=gene_names, regulators=regulators,file_name=os.path.join(rnd_results_dir, 'ranking_iter_'+str(k)+'_rndBlock_'+str(blocknames[i])+'.txt'))

        i = i+1

print('Result folder time stamp: ' + str(dateStart))
